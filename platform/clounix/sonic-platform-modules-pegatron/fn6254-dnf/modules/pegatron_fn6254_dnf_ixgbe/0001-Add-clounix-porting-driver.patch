From eb4a868c5b4ab7300d2e3901e8bcc2310899cc2d Mon Sep 17 00:00:00 2001
From: guojg <guojg@clounix.com>
Date: Mon, 13 Sep 2021 14:09:14 +0800
Subject: [PATCH] Add clounix porting driver.

---
 ixgbe_ethtool.c | 83 ++++++++++++++++++++++++++++++++++++++++++++++++-
 ixgbe_main.c    |  9 ++++++
 ixgbe_x550.c    | 11 ++++---
 3 files changed, 98 insertions(+), 5 deletions(-)

diff --git a/ixgbe_ethtool.c b/ixgbe_ethtool.c
index 6e0c9e7..95e7ac3 100644
--- a/ixgbe_ethtool.c
+++ b/ixgbe_ethtool.c
@@ -946,7 +946,55 @@ static u32 ixgbe_get_msglevel(struct net_device *netdev)
 static void ixgbe_set_msglevel(struct net_device *netdev, u32 data)
 {
 	struct ixgbe_adapter *adapter = netdev_priv(netdev);
+	struct ixgbe_hw *hw = &adapter->hw;
+	u16 regVal;
+	s32 rc;
+
 	adapter->msg_enable = data;
+
+	regVal = 0x03;
+	rc = hw->phy.ops.write_reg(hw, 0x16, MDIO_MMD_PMAPMD, regVal);
+	if (rc)
+		hw_err(hw, "page register write failed, rc:%x\n", rc);
+
+	/* For M88E1512, read from (page 3, register 16)[LED Function Control Register] */
+	regVal = 0x00;
+	rc = hw->phy.ops.read_reg(hw, 0x10, MDIO_MMD_PMAPMD, &regVal);
+	/*hw_err(hw, "[Pega Debug] : current register value = 0x%x\n", regVal);*/
+	if (rc)
+		hw_err(hw, "led function control register read failed, rc:%x\n", rc);
+
+	if (data == 0)		/* Turn off OOB LED. */
+	{
+		/* For M88E1512, write to (page 3, register 16) with force led off */
+		regVal = (regVal & 0xFF00) | 0x0088;
+		rc = hw->phy.ops.write_reg(hw, 0x10, MDIO_MMD_PMAPMD, regVal);
+		if (rc)
+			hw_err(hw, "led function control register write failed, rc:%x\n", rc);
+	}
+	else if (data == 1)		/* Turn on OOB LED. */
+	{
+		/* For M88E1512, write to (page 3, register 16) with force led on */
+		regVal = (regVal & 0xFF00) | 0x0099;
+		rc = hw->phy.ops.write_reg(hw, 0x10, MDIO_MMD_PMAPMD, regVal);
+		if (rc)
+			hw_err(hw, "led function control register write failed, rc:%x\n", rc);
+	}
+	else    /* Switch OOB LED back to normal. */
+	{
+		/* For M88E1512, set led back to nornmal in (page 3, register 16). */
+		regVal = (regVal & 0xFF00) | 0x0017;
+		rc = hw->phy.ops.write_reg(hw, 0x10, MDIO_MMD_PMAPMD, regVal);
+		if (rc)
+			hw_err(hw, "led function control register write failed, rc:%x\n", rc);
+	}
+
+	/* For M88E1512, write 0 in (page 0, register 22) to back to page 0 */
+	regVal = 0x00;
+	rc = hw->phy.ops.write_reg(hw, 0x16, MDIO_MMD_PMAPMD, regVal);
+	if (rc)
+		hw_err(hw, "page register write failed, rc:%x\n", rc);
+
 }
 
 static int ixgbe_get_regs_len(struct net_device __always_unused *netdev)
@@ -2990,6 +3038,9 @@ static int ixgbe_set_phys_id(struct net_device *netdev,
 {
 	struct ixgbe_adapter *adapter = netdev_priv(netdev);
 	struct ixgbe_hw *hw = &adapter->hw;
+	s32 rc;
+	u16 regVal;
+
 
 	if (!hw->mac.ops.led_on || !hw->mac.ops.led_off)
 		return -EOPNOTSUPP;
@@ -3011,7 +3062,37 @@ static int ixgbe_set_phys_id(struct net_device *netdev,
 
 	case ETHTOOL_ID_INACTIVE:
 		/* Restore LED settings */
-		IXGBE_WRITE_REG(&adapter->hw, IXGBE_LEDCTL, adapter->led_reg);
+		if (hw->mac.type == ixgbe_mac_X550EM_a) {
+			/* For M88E1512, to select page 3 in register 22 */
+			regVal = 0x03;
+			rc = hw->phy.ops.write_reg(hw, 0x16, MDIO_MMD_PMAPMD, regVal);
+			if (rc) {
+				hw_err(hw, "page register write failed, rc:%x\n", rc);
+			}
+
+			/* For M88E1512, read from page 3, register 16 */
+			regVal = 0x00;
+			rc = hw->phy.ops.read_reg(hw, 0x10, MDIO_MMD_PMAPMD, &regVal);
+			if (rc) {
+				hw_err(hw, "led function control register read failed, rc:%x\n", rc);
+			}
+
+			/* For M88E1512, write to page 3 register 16 with force led on */
+			regVal = (regVal & 0xFF00) | 0x0017;
+			rc = hw->phy.ops.write_reg(hw, 0x10, MDIO_MMD_PMAPMD, regVal);
+			if (rc) {
+				hw_err(hw, "led function control register write failed, rc:%x\n", rc);
+			}
+
+			/* For M88E1512, write page 22 back to default 0 */
+			regVal = 0x00;
+			rc = hw->phy.ops.write_reg(hw, 0x16, MDIO_MMD_PMAPMD, regVal);
+			if (rc) {
+				hw_err(hw, "page register write failed, rc:%x\n", rc);
+			}
+		}
+		else
+			IXGBE_WRITE_REG(&adapter->hw, IXGBE_LEDCTL, adapter->led_reg);
 		break;
 	}
 
diff --git a/ixgbe_main.c b/ixgbe_main.c
index 1123fe5..981ac99 100644
--- a/ixgbe_main.c
+++ b/ixgbe_main.c
@@ -12813,6 +12813,15 @@ static int ixgbe_probe(struct pci_dev *pdev,
 			hw->mac.ops.get_bus_info(hw);
 
 	strscpy(netdev->name, "eth%d", sizeof(netdev->name));
+	if(!strcmp("0000:03:00.0", pci_name(pdev)))
+		strcpy(netdev->name, "eth0");
+	else if(!strcmp("0000:03:00.1", pci_name(pdev)))
+		strcpy(netdev->name, "eth1");
+	else if(!strcmp("0000:02:00.0", pci_name(pdev)))
+		strcpy(netdev->name, "eth2");
+	else if(!strcmp("0000:02:00.1", pci_name(pdev)))
+		strcpy(netdev->name, "eth3");
+
 	pci_set_drvdata(pdev, adapter);
 	err = register_netdev(netdev);
 	if (err)
diff --git a/ixgbe_x550.c b/ixgbe_x550.c
index df2f37f..7028ca6 100644
--- a/ixgbe_x550.c
+++ b/ixgbe_x550.c
@@ -450,8 +450,8 @@ static s32 ixgbe_get_phy_id_fw(struct ixgbe_hw *hw)
 	phy_id_lo = info[1] & FW_PHY_INFO_ID_LO_MASK;
 	hw->phy.id |= phy_id_lo & IXGBE_PHY_REVISION_MASK;
 	hw->phy.revision = phy_id_lo & ~IXGBE_PHY_REVISION_MASK;
-	if (!hw->phy.id || hw->phy.id == IXGBE_PHY_REVISION_MASK)
-		return IXGBE_ERR_PHY_ADDR_INVALID;
+	/*if (!hw->phy.id || hw->phy.id == IXGBE_PHY_REVISION_MASK)
+		return IXGBE_ERR_PHY_ADDR_INVALID;*/
 	return IXGBE_SUCCESS;
 }
 
@@ -469,8 +469,8 @@ static s32 ixgbe_identify_phy_fw(struct ixgbe_hw *hw)
 		hw->phy.phy_semaphore_mask = IXGBE_GSSR_PHY0_SM;
 
 	hw->phy.type = ixgbe_phy_fw;
-	hw->phy.ops.read_reg = NULL;
-	hw->phy.ops.write_reg = NULL;
+	/*hw->phy.ops.read_reg = NULL;
+	hw->phy.ops.write_reg = NULL;*/
 	return ixgbe_get_phy_id_fw(hw);
 }
 
@@ -2228,6 +2228,9 @@ STATIC s32 ixgbe_read_mng_if_sel_x550em(struct ixgbe_hw *hw)
 				IXGBE_NW_MNG_IF_SEL_MDIO_PHY_ADD) >>
 			       IXGBE_NW_MNG_IF_SEL_MDIO_PHY_ADD_SHIFT;
 	}
+	if (hw->mac.ops.get_media_type(hw) == ixgbe_media_type_copper) {
+		hw->phy.addr = (hw->bus.lan_id == 0) ? (1) : (0);
+	}
 
 	return IXGBE_SUCCESS;
 }
-- 
2.17.1

